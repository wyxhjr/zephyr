/*
 * Copyright (c) 2024 Zephyr Contributors
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/logging/log.h>
#include <zephyr/drivers/interrupt_controller/riscv_imsic.h>

LOG_MODULE_REGISTER(imsic_mmio_test, LOG_LEVEL_INF);

/* Test configuration */
#define TEST_EID 10

/* Main test function */
int main(void)
{
    LOG_INF("=== RISC-V IMSIC MMIO Test ===");
    LOG_INF("üéØ Testing IMSIC MMIO register access");
    LOG_INF("üöÄ Starting in 3 seconds...");
    
    /* Wait for system stabilization */
    k_msleep(3000);
    
    LOG_INF("üé¨ Starting MMIO tests...");
    
    /* Test 1: Get IMSIC device */
    LOG_INF("=== Test 1: IMSIC Device Access ===");
    const struct device *imsic_dev = riscv_imsic_get_dev();
    if (!imsic_dev || !device_is_ready(imsic_dev)) {
        LOG_ERR("‚ùå IMSIC device not available");
        return -1;
    }
    LOG_INF("‚úÖ IMSIC device: %s", imsic_dev->name);
    
    /* Test 2: Basic interrupt enable/disable */
    LOG_INF("=== Test 2: Basic Interrupt Control ===");
    
    LOG_INF("üîì Enabling interrupt for EID %u...", TEST_EID);
    riscv_imsic_irq_enable(TEST_EID);
    
    int enabled = riscv_imsic_irq_is_enabled(TEST_EID);
    if (enabled > 0) {
        LOG_INF("‚úÖ EID %u: Enabled successfully", TEST_EID);
    } else {
        LOG_ERR("‚ùå EID %u: Enable failed", TEST_EID);
        return -1;
    }
    
    LOG_INF("üîí Disabling interrupt for EID %u...", TEST_EID);
    riscv_imsic_irq_disable(TEST_EID);
    
    enabled = riscv_imsic_irq_is_enabled(TEST_EID);
    if (enabled <= 0) {
        LOG_INF("‚úÖ EID %u: Disabled successfully", TEST_EID);
    } else {
        LOG_WRN("‚ö†Ô∏è  EID %u: Disable failed", TEST_EID);
    }
    
    /* Test 3: Interrupt pending (safe test) */
    LOG_INF("=== Test 3: Interrupt Pending Test ===");
    
    /* Re-enable for testing */
    riscv_imsic_irq_enable(TEST_EID);
    
    LOG_INF("üì° Setting interrupt pending for EID %u...", TEST_EID);
    riscv_imsic_irq_set_pending(TEST_EID);
    LOG_INF("‚úÖ Interrupt pending set successfully");
    
    LOG_INF("üßπ Clearing interrupt pending for EID %u...", TEST_EID);
    riscv_imsic_irq_clear_pending(TEST_EID);
    LOG_INF("‚úÖ Interrupt pending cleared successfully");
    
    /* Test 4: Threshold test (this will test MMIO to EITHRESHOLD) */
    LOG_INF("=== Test 4: Threshold Test (MMIO to EITHRESHOLD) ===");
    
    uint32_t old_threshold = riscv_imsic_get_threshold();
    LOG_INF("üìä Current threshold: %u", old_threshold);
    
    LOG_INF("üìä Setting threshold to 2...");
    int ret = riscv_imsic_set_threshold(2);
    if (ret == 0) {
        uint32_t new_threshold = riscv_imsic_get_threshold();
        LOG_INF("‚úÖ Threshold set to %u (was %u)", new_threshold, old_threshold);
        
        /* Restore threshold */
        riscv_imsic_set_threshold(old_threshold);
        LOG_INF("üìä Threshold restored to %u", old_threshold);
    } else {
        LOG_WRN("‚ö†Ô∏è  Failed to set threshold: %d", ret);
    }
    
    /* Test 5: Delivery mode test (this will test MMIO to EIDELIVERY) */
    LOG_INF("=== Test 5: Delivery Mode Test (MMIO to EIDELIVERY) ===");
    
    enum riscv_imsic_delivery_mode old_mode = riscv_imsic_get_delivery_mode();
    LOG_INF("üìä Current delivery mode: %d", old_mode);
    
    LOG_INF("üìä Setting delivery mode to MSI...");
    ret = riscv_imsic_set_delivery_mode(RISCV_IMSIC_DELIVERY_MODE_MSI);
    if (ret == 0) {
        enum riscv_imsic_delivery_mode new_mode = riscv_imsic_get_delivery_mode();
        LOG_INF("‚úÖ Delivery mode set to %d (was %d)", new_mode, old_mode);
        
        /* Restore mode */
        riscv_imsic_set_delivery_mode(old_mode);
        LOG_INF("üìä Delivery mode restored to %d", old_mode);
    } else {
        LOG_WRN("‚ö†Ô∏è  Failed to set delivery mode: %d", ret);
    }
    
    /* Final summary */
    LOG_INF("üéâ === MMIO Test Summary ===");
    LOG_INF("‚úÖ IMSIC device access: WORKING");
    LOG_INF("‚úÖ Interrupt enable/disable: WORKING");
    LOG_INF("‚úÖ Interrupt pending control: WORKING");
    LOG_INF("‚úÖ Threshold MMIO access: %s", (ret == 0) ? "WORKING" : "FAILED");
    LOG_INF("‚úÖ Delivery mode MMIO access: %s", (ret == 0) ? "WORKING" : "FAILED");
    
    LOG_INF("üîÑ Keeping system running for observation...");
    
    /* Keep the system running */
    for (int i = 0; i < 10; i++) {
        k_msleep(2000);
        LOG_INF("üíª System running normally... iteration %d/10", i + 1);
    }
    
    LOG_INF("üèÅ Test completed successfully. System will continue running.");
    
    /* Final status loop */
    while (1) {
        k_msleep(5000);
        LOG_INF("üíª System status: IMSIC MMIO working");
    }
    
    return 0;
}
